#!/bin/bash
#
# Author:   kyo <iprintf@qq.com>
# Date:     2017-01-10 16:54:54
# Location: Shenzhen
# Desc: Use 'log-with-git' to encrypt store.
#

myexit() {
    echo $1
    exit ${2-1}
}

vim_last_cmd() {
    local viminfo=~/.viminfo
    test ! -e $viminfo && echo None
    grep -m1 '^:' $viminfo 2> /dev/null
}

log_add() {
    # 临时文件必须不存在，否则视为上次编辑出错
    # 编辑结束, vim最后一条命令为q!、文件不存在或为空代表不保存此文档
    # test -e "$tmpfile" && myexit "为什么会存在此文件，请检查!"
    tmpfile=$(mktemp)

    vim "+set ff=unix foldlevel=0" $tmpfile

    test ! -e "$tmpfile" && return 1
    local filesize=$(wc -c "$tmpfile" | awk '{print $1}')
    test "$filesize" -eq 0 && return 1
    test "$(vim_last_cmd)" == ":q!" && return 1

    if test "x$1" == "x-m" ;then
        local ms="$(date +%F)"
        local opt=""
    else
        local ms="$(sed -n "1p" $tmpfile)"
        local opt="-e"
    fi
    cat $tmpfile | $gpg -ae | $log add $opt -m "$ms"

    return 1
}

# 抽取日志字段组合标题与头信息
parse_header() {
    local id=$1
    test -z "$id" && myexit "没有指定ID!"

    local subject=$($log list $id -f '%s')
    test -z "$subject" && myexit "没有匹配到指定日志!"

    local time=$($log list $id -f '%t')
    test -z "$time" && myexit "指定日志格式有误!"
    time="#    time   = $time"

    local scene=$($log list $id -f '%c')
    local people=$($log list $id -f '%p')
    local tag=$($log list $id -f '%g')

    echo "$subject"
    echo
    echo '# Log Info {'
    echo "$time"
    test ! -z "$scene" && echo "#    scene  = $scene"
    test ! -z "$people" && echo "#    people = $people"
    test ! -z "$tag" && echo "#    tag    = $tag"
    echo '# Log Info }'
}

# 解密日志组合字段到临时文件中，打印文件名
get_defile() {
    local id=$1
    # 抽取日志字段解密组合到临时文件中
    local header=$(parse_header $id)
    test $? -ne 0 && myexit $header
    local data=$($log list $id -f "%d" | $gpg -d 2> /dev/null)
    test $? -ne 0 && myexit "GPG解密失败，请检查!"

    #生成临时文件存储要编辑的内容(用于对比编辑后是否修改了内容)
    local oldfile=$(mktemp)
    cat > "$oldfile" << EOF
$header

$data
EOF
    echo $oldfile
}

# 配合get_id函数使用，有多条记录选择打印ID
choice_id() {
    local line show ids n=0 id date time title i
    local list="$1"

    # echo "$list"
    # echo "=================="
    while read line ; do
        read ids[$n] date time title <<< \
            $(awk -F'|' '{print $1,$2,$3}' <<< "$line")
        # echo "${ids[$n]}", $id, $date, $time, $title
        # awk -F'|' '{print $1,$2,$3,$4}' <<< "$line"
        id=${ids[$n]:0:7}
        i="\033[32m%4d.\033[33m$id\033[37m($date $time)\033[0m: $title\n"
        show[$n]=$(printf "$i" "$n")
        # show[$n]="\033[32m$n.\033[33m$id\033[37m($date $time)\033[0m: $title"
        let n++
    done <<< "$list"

    # 小于等于10条记录选择编辑, 否则只是less查看
    if test "$n" -gt 10 ; then
        for i in $(seq 0 $[n - 1]) ; do
            echo -e "${show[$i]}"
        done | less -XRF
        myexit
    fi

    while true ; do
        for i in $(seq 0 $[n - 1]) ; do
            echo -e "${show[$i]}"
        done
        read -n 1 -p "choice> " line
        test "$line" == "q" && myexit
        echo
        egrep -q '^[0-9]+$' &> /dev/null <<< "$line" || continue
        test -z "${ids[$line]}" && continue
        logID="${ids[$line]}"
        break
    done
}

# 根据参数自动获取ID, 如果只有一条记录则直接返回ID，有多条记录则进入选择ID
get_id() {
    local opt="$1"
    # 如果没有参数则默认为-1
    test -z "$opt" && opt=-1 || opt="$@"
    # echo "$log list $opt"
    # $log list $opt -f "%i"
    # 获取指定条件的列表, 字段以|为分隔符
    local list=$($log list $opt -f "%I|%mtk|%s")
    # 程序出错或没有记录报错
    test $? -ne 0 -o "x$list" == "x" && myexit "程序出错: 没有匹配到数据!"
    # 获取列表个数
    local line=$(wc -l <<< "$list")
    # 如果只有一条记录则返回sha1值
    if test "$line" -eq 1 ; then
        logID=$(awk -F'|' '{print $1}' <<< "$list")
    else
        choice_id "$list"
    fi
}

# 列表选择编辑
choice_edit() {
    logID=""
    get_id "$@"
    test -z "$logID" && myexit "没有匹配到ID!"
    $0 edit "$logID"
}

log_edit() {
    # 临时文件必须不存在，否则视为上次编辑出错
    # 分别取出编辑指定日志的字段进行组合到临时文件中(数据本身解密)
    # 启动编辑器进行编辑，编辑完成退出后取出数据字段进行加密
    # 再通过log edit ID -s -r file来更新日志程序
    # test -e "$tmpfile" && myexit "为什么会存在此文件，请检查!"
    local id
    logID=""
    get_id "$1"
    test -z "$logID" && myexit "没有匹配到ID!"
    id="$logID"

    # 判断是否为GPG加密日志，如果不是则使用普通edit
    if ! $log list "$id" -f "%d" | grep 'BEGIN PGP MESSAGE' &> /dev/null
    then
        kvimopt="'$vimopt'" $log edit "$id"
        return
    fi

    # 获取解密后数据及文件头的组合临时文件
    local oldfile=$(get_defile $id)
    test ! -f "$oldfile" && myexit $oldfile

    # 生成编辑的临时文件，数据来自于$oldfile
    tmpfile=$(mktemp)
    cat "$oldfile" > "$tmpfile"

    # 启动编辑器开始编辑
    vim "$vimopt" "$tmpfile"

    # 文件内容为空或强制退出的视为不保存此时的编辑
    local filesize=$(wc -c "$tmpfile" | awk '{print $1}')
    test "$filesize" -eq 0 && return 1
    test "$(vim_last_cmd)" == ":q!" && return 1

    # 对比编辑后文件内容是否修改改，如果没有修改则退出
    if diff "$tmpfile" "$oldfile" &> /dev/null ;then
        rm $oldfile -f
        return 1
    fi
    rm $oldfile -f

    # 分别取出字段，对数据进行加密再组合输入到日志系统中
    local subject=$(sed '/# \?log \?Info \?}/I,$d' "$tmpfile")
    local data=$(sed '1,2d' "$tmpfile"                              \
            | sed '/# \?Log \?Info \?{/I,/# \?Log \?Info \?}/Id'    \
            | sed '/./,$!d' | $gpg -ae)
    cat > "$tmpfile" << EOF
$subject
# Log Info }

$data
EOF
    $log edit $id -s -r "$tmpfile"

    return 1
}


# tag命令的实现函数
log_tag() {
    if test -z "$1" ; then
        $log list -f '%g' | sort | uniq -c | sort -rn | less
    elif test "x$1" == "x--all" -o "x$1" == "x-a"; then
        $log list -f '%g' | sed -r 's/,/\n/g'  \
               | sort | uniq -c | sort -rn | less
    else
        choice_edit -S "tag/$1/"
    fi
}

# file命令的实现函数
kyo_log_file() {
    test -z "$1" && myexit "请指定要打开文件的ID或指定添加文件的路径!"
    if test -f "$1" ; then
        test -z "$1" &&  myexit "必须指定要添加的文件路径!"
        test ! -f "$1" && myexit "必须指定有效文件路径!"
        cat "$1" | $gpg -e | base64 | kdy add -m "$1" -e
    else
        local tag=$($0 list "$1" -f "%g")
        local logo=$(awk -F',' '{print $1}' <<< "$tag")
        if test "x$logo" != "xfile" ; then
            $0 edit "$1"
        else
            local file_type=$(awk -F',' '{print $2}' <<< "$tag")
            local file=/dev/shm/kyo_log_file.$file_type
            $0 list "$1" -f '%d' | base64 -d | $gpg > $file
            test ! -e $file && my_exit "文件解密失败!"
            case "$file_type" in
                doc|docx|xls|ppt)
                    local program='soffice --view '
                ;;
                pdf)
                    local program='evince'
                    ;;
                jpg|jpeg|png|gif)
                    local program='eog'
                    ;;
                *)
                    local program=''
                    ;;
            esac
            test ! -z "$program" && $program $file && rm $file -f
        fi
    fi
}

# log="note -F $HOME/.logenrc"
gpg="gpg --batch -q -r iprintf@qq.com"

# test -z $klogrc && log="note -F $HOME/.logenrc" || log="note -F $klogrc"
# test -z $klogrc && log="note -F $HOME/.logtest" || log="note -F $klogrc"
test -z $klogrc && log="note" || log="note -F $klogrc"
test -z $kdytime && kdytime="-mt"

cmd=${1-list}

case "$cmd" in
    add|a)
        shift
        $log add "$@"
        ;;
    file)
        shift
        kyo_log_file "$@"
        ;;
    en)
        shift
        log_add "$1" || rm "$tmpfile" -f
        ;;
    read|r)
        shift
        $0 edit -l "$@"
        ;;
    edit|e)
        shift
        vimopt="+set ff=unix foldlevel=0 "
        if test ! -z "$1" -a "$1" == "-l" ;then
            vimopt+=" nomodifiable buftype=nofile"
            shift
        fi
        log_edit "$@" || rm "$tmpfile" -f
        ;;
    tag|t)
        shift
        log_tag "$@"
        ;;
    time)
        shift
        choice_edit $kdytime "$@"
        ;;
    year|y)
        shift
        test -z "$1" && t=$(date +%Y) || t="$1"
        choice_edit $kdytime "$t"
        ;;
    month|m)
        shift
        test -z "$1" && t=$(date +%Y%m) || t="$(date +%Y)$1"
        choice_edit $kdytime "$t:"
        ;;
    day|d)
        shift
        if test -z "$1" ; then
            t=$(date +%Y%m%d)
        else
            t="$1"
            if egrep -q '^\-[0-9]+$' &> /dev/null <<< "$t"; then
                t="$(date -d "$t day" +%Y%m%d)"
            else
                t="$(date +%Y%m)$1"
            fi
        fi
        # echo $t
        choice_edit $kdytime "$t"
        ;;
    week|w)
        shift
        t=$(date +%w)
        let t--
        t=$(date -d "$(date +%F) -$t day" +%Y%m%d)
        choice_edit $kdytime "$t:"
        ;;
    lock)
        shift
        #立即清除密码缓存, 下次解密需要输入密码
        which gpg-connect-agent &> /dev/null || myexit "请安装gunpg-agent!"
        gpg-connect-agent reloadagent /bye
        myexit
        ;;
    *)
        if egrep -q '^-?[0-9a-f]+$' &> /dev/null <<< "$cmd"; then
            $0 edit $cmd
        else
            $log "$@"
        fi
        ;;
esac
